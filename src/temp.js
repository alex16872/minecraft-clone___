// The container for the whole thing
// ==================================
var view = document.getElementById("container");
var startDiv = document.getElementById("start");
var statsDiv = document.getElementById("stats");
var sceneDiv = document.getElementById("scene");

// The UI thread
// ==============
// This is where the calls to/from the generation
// thread occur.
// ------------------------------------------------
var camera, scene, renderer, controls, light, worker, clock;
var camOffset = new THREE.Vector3(2, 2, 2);
var jobs = new Array();
var lite = 0xffffff;
var dark = 0x505050;
var mid = 0xa7a7a7;

// Our render function, handles the creation of geometry
// as it is generated by our background thread.
function processJob(data) {
  var geometry = new THREE.Geometry();
  var vertexBuffer = new Float32Array(data.vertices);
  var faceBuffer = new Int32Array(data.faces);
  var colorBuffer = new Int8Array(data.colors);
  var lightBuffer = new Int8Array(data.lights);

  for (var i = 0; i < vertexBuffer.length; i += 3) {
    geometry.vertices.push(
      new THREE.Vector3(
        vertexBuffer[i],
        vertexBuffer[i + 1],
        vertexBuffer[i + 2]
      )
    );
  }

  for (var j = 0; j < faceBuffer.length; j += 3) {
    geometry.faces.push(
      new THREE.Face3(faceBuffer[j], faceBuffer[j + 1], faceBuffer[j + 2])
    );
    var index = geometry.faces.length - 1;

    var l = lightBuffer[j / 3];
    var color;
    if (l > 1) color = 0x111111 * (l - 1);
    else if (l == 1) color = 0x080808;
    else color = 0x000000;

    var vColor = colorBuffer[j] == 0 ? lite : colorBuffer[j] == 1 ? mid : dark;
    vColor = vColor < color ? vColor : color;
    geometry.faces[index].vertexColors[0] = new THREE.Color(vColor);

    vColor =
      colorBuffer[j + 1] == 0 ? lite : colorBuffer[j + 1] == 1 ? mid : dark;
    vColor = vColor < color ? vColor : color;
    geometry.faces[index].vertexColors[1] = new THREE.Color(vColor);

    vColor =
      colorBuffer[j + 2] == 0 ? lite : colorBuffer[j + 2] == 1 ? mid : dark;
    vColor = vColor < color ? vColor : color;
    geometry.faces[index].vertexColors[2] = new THREE.Color(vColor);
  }

  geometry.computeFaceNormals(); // Pass Normals back? Would it help?
  geometry.computeBoundingBox();
  geometry.computeBoundingSphere();

  var material = new THREE.MeshBasicMaterial({
    vertexColors: THREE.VertexColors,
  });

  var mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(data.x, data.y, data.z);
  scene.add(mesh);
  Render();
}

var lastNow = 0;
function Animate() {
  lastNow = Date.now();
  var time = 0;
  clock.getDelta();
  while (jobs.length > 0 && (time += clock.getDelta()) < 0.016) {
    var data = jobs.shift();

    processJob(data);
  }

  requestAnimationFrame(Animate);
  controls.update();
}

function Render() {
  renderer.render(scene, camera);
}

function onWindowResize() {
  var h = window.innerHeight - 20;
  var w = window.innerWidth - 150;

  var fov = (Math.atan(h / (2 * 482.84)) * 360) / Math.PI;
  camera.aspect = w / h;
  camera.fov = fov;
  camera.updateProjectionMatrix();

  renderer.setSize(w, h);
  Render();
}

function Init(height, width, depth) {
  scene = new THREE.Scene();
  clock = new THREE.Clock();

  var FOV, WIDTH, HEIGHT, ASPECT, NEAR, FAR;
  WIDTH = window.innerWidth - 150;
  HEIGHT = window.innerHeight - 20;
  FOV = (Math.atan(HEIGHT / (2 * 482.84)) * 360) / Math.PI;
  ASPECT = WIDTH / HEIGHT;
  NEAR = 0.1;
  FAR = 10000;

  camera = new THREE.PerspectiveCamera(FOV, ASPECT, NEAR, FAR);
  camera.position.set(width / 2, height * 2, depth * 2);
  camera.lookAt(new THREE.Vector3(width / 2, height / 2, depth / 2));

  controls = new THREE.OrbitControls(camera);
  controls.addEventListener("change", Render);
  controls.target = new THREE.Vector3(width / 2, height / 2, depth / 2);

  renderer = new THREE.WebGLRenderer();
  renderer.setClearColor(0xededed);
  renderer.setSize(WIDTH, HEIGHT);

  document.getElementById("container").appendChild(renderer.domElement);

  renderer.render(scene, camera);

  window.addEventListener("resize", onWindowResize, false);
}

function Start(seed) {
  var blob = new Blob(
    Array.prototype.map.call(
      document.querySelectorAll('script[type="text/js-worker"]'),
      function (s) {
        return s.textContent;
      }
    ),
    {
      type: "text/javascript",
    }
  );

  worker = new Worker(window.URL.createObjectURL(blob));
  worker.postMessage({
    cmd: "init",
    seed: seed,
  });

  worker.addEventListener("message", function (e) {
    var data = e.data;
    switch (data.cmd) {
      case "ready":
        worker.postMessage({
          cmd: "gen",
          x: 0,
          y: 0,
          z: 0,
          w: 256,
          h: 128,
          d: 256,
        });
        break;
      case "chunk":
        jobs.push(data);
        break;
      case "stat":
        var label = document.createElement("div");
        label.id = data.label;
        label.innerHTML = data.label;
        label.className += " statLabel";
        var value = document.createElement("div");
        value.className += " statValue";
        value.innerHTML = data.value;
        statsDiv.appendChild(label);
        statsDiv.appendChild(value);

        if (data.label.startsWith("Geometry") && Date.now() - lastNow > 1200) {
          console.log("-.-");
          setTimeout(processPreview, 1);
        }
        break;
    }
  });
}

function processPreview() {
  if (jobs.length > 0) {
    var data = jobs.shift();
    processJob(data);
    setTimeout(processPreview, 1);
  }
}
